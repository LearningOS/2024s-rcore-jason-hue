### 荣誉准则

在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

《你交流的对象说明》:与第二阶段群友交流了如何排错debug

此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

《你参考的资料说明》：rcore v3 book

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

### 经历
第一步需要重新写sys_get_time和taskInfo，刚开始没有想到为什么这两个要重写，去查了一下资料，补了一下盲区:系统调用时是从某个应用的地址空间切换到内核的地址空间，而syscall传进来的那个指针是用户空间里的虚拟地址，在内核是无法直接用的。这个点一下明白过来之后，就很好写了，加一个函数用来手动将用户空间的虚拟地址翻译成物理地址。写一个函数translate_struct_ptr用来翻译地址，最开始没有想起用泛型函数，直接写的函数的返回值为*const usize，结果发现rust要求返回值要和syscall传进来的结构体要类型一致，然后我就试着强转为*TimeVal.....*TaskInfo.....这样虽然不报错了，但是还是输出不对。想了一会，想起来应该用泛型，这样一下就解决了类型不一致的问题。mmap和munmap还比较简单，就在port卡了一下，然后就是增加一个Btree塞进memorySet里用来申请内存，这个比较好实现。有个bug卡了很久，我lab1获取syscall_times的方法直接搬到lab2居然会触发panic，在第二次系统调用的时候，翻译地址触发了查找不存在的物理页错误，不断debug才发现原因所在，最后该了get_syscall_times的实现，就好了。

完了，我好像lab1忘写问答题了

### 问答作业：
1. SV39页表项由物理页号和标志位组成，最底的8位是标志位，含义： 
- 仅当 V(Valid) 位为 1 时，页表项才是合法的;
- R/W/X 分别控制索引到这个页表项的对应虚拟页面是否允许读/写/取指；
- U 控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；
- G 我不知道
- A(Accessed) 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；
- D(Dirty) 则记录自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过。

2. 缺页可能导致的异常包括：
- Page Fault（页错误）：当进程访问一个不在内存中的页面时，会触发页错误异常。这个异常会被操作系统捕获，操作系统会根据情况执行相应的操作，比如将页面从磁盘加载到内存，更新页表，然后重新执行引起异常的指令。
- Segmentation Fault（段错误）：虽然缺页通常是指的页面级别的内存访问错误，但在某些情况下，也可能导致段错误。比如，当访问一个未分配的内存段或者超出了合法内存段的边界时，可能会触发段错误。
- General Protection Fault（通用保护错误）：这是一种由于对受保护的内存区域的非法访问而触发的异常。如果缺页导致了对受保护的内存区域的访问，可能会引发通用保护错误。

在发生缺页时，描述相关重要寄存器的值可能包括：
- PC 寄存器：保存引起页错误的指令的地址。
- CR2 寄存器：保存引起页错误的内存地址（缺页地址）。
- 页表寄存器（Page Table Register）：保存当前进程的页表基地址。

关于 Lazy 策略的好处：

Lazy 策略可以节省内存和CPU资源，因为它只有在实际需要时才会将页面加载到内存中。这样做可以避免在进程启动时就加载整个程序的代码和数据，尤其对于大型程序来说，可以减少启动时间和内存占用。另外，Lazy 策略也可以避免加载不需要的部分，从而减少了不必要的磁盘 I/O。

关于对应 SV39 页表占用内存的估算：

SV39 页表将虚拟地址划分为三级页表，每级页表包含 512 个页表项。对于 10G 的连续内存页面，可以估算如下：

- 第一级页表：需要 512 个页表项，每个页表项 8 字节（64 位系统），总计 4KB。
- 第二级页表：需要 512 个页表项，每个页表项 8 字节，总计 4KB。
- 第三级页表：需要 512 个页表项，每个页表项 8 字节，总计 4KB。
因此，SV39 页表大致占用 12KB 的内存。

关于如何实现 Lazy 策略以及缺页处理：

Lazy 策略的实现可以在进程访问页面时触发缺页异常，然后操作系统可以将页面从磁盘加载到内存中，并更新页表。处理缺页时，可以通过将页面加载到内存中并更新页表来实现 Lazy 策略。对于已经加载到内存中但是被交换到磁盘的页面，操作系统可以通过交换机制将页面重新加载到内存中。在缺页处理过程中，操作系统还可以进行一些优化，比如使用预取机制提前将可能需要的页面加载到内存中，以减少缺页发生的频率。

3. 双页表与单页表

- 准备新的页表：首先，准备一个新的页表，其中包含了需要切换到的新的地址映射。
- 切换页表：然后，将新的页表的基地址加载到相应的页表寄存器中，比如 x86 架构中的 CR3 寄存器。这样就完成了页表的更换。
在单页表情况下，要控制用户态无法访问内核页面，可以通过以下方式实现：

- 分离用户态和内核态地址空间：在单页表设计中，可以将用户态和内核态的地址空间分开管理。只在内核态时才允许访问内核页面，而在用户态时则只允许访问用户页面。这可以通过设置合适的权限位或者使用分段机制来实现。
- 设置访问权限：在单页表中，可以通过设置页面的访问权限，比如设置内核页面为只读或者不可访问，从而阻止用户态程序对内核页面的访问。

单页表的优势包括：
- 简单直观：单页表的设计相对简单，容易理解和实现。
- 资源消耗较少：单页表只需要维护一张页表，节省了内存和其他资源。

在双页表实现下，需要更换页表的情况通常包括：
- 进程切换：当操作系统切换到一个新的进程时，可能需要更换页表，以加载新进程的地址映射。
- 内存保护：当需要更新某些页面的访问权限或者需要将某些页面从内存中移除时，可能需要更换页表。

如果我写一个单页表操作系统，我可能会选择在以下情况下更换页表：
- 进程切换：当操作系统切换到一个新的用户进程时，可以选择更换页表，以加载新进程的地址映射。这样可以确保每个进程都拥有自己独立的地址空间，增加了安全性和隔离性。
- 内存保护：当需要更新某些页面的访问权限或者需要将某些页面从内存中移除时，也可以选择更换页表，以更新地址映射和访问权限。




